package main

import "fmt"

/*
append() 给切片追加新元素:
切片 = append(切片, 追加的元素) append()是一个函数 返回值必须用这个切片变量进行接收
*/
/*
copy 将一个切片的数据复制到另一个切片空间中
copy(要复制到的切片, 存有待复制数据的切片, []切片数据类型)
*/
func main() {
	// append()
	// 声明一个切片
	var a = []string{"河南", "河北", "山东", "山西"}
	// a[4] = "江苏"  // 不合法 index out of range 超出了切片的长度 追加新元素应该使用append
	fmt.Println("扩容前:", len(a), cap(a), a) // 扩容前: 4 4 [河南 河北 山东 山西]
	a = append(a, "江苏")
	fmt.Println("扩容后:", len(a), cap(a), a) // 扩容后: 5 8 [河南 河北 山东 山西 江苏]
	var b []string
	b = append(a, "江苏")                             // 相当于给切片a追加元素之后再赋值给切片b
	fmt.Println("追加之后赋值给另一个切片:", len(b), cap(b), b) // 追加之后赋值给另一个切片: 6 8 [河南 河北 山东 山西 江苏 江苏]
	fmt.Println("对原本的切片没有影响:", len(a), cap(a), a)   // 对原本的切片没有影响: 5 8 [河南 河北 山东 山西 江苏]
	// append函数追加元素 原本的底层数组长度不足时 Go底层会换一个底层数组 将新的底层数组作为返回值//
	// 因此原本的切片需要重新指向这个底层数组 因此必须要用切片变量进行接收
	// 将一个切片中的每个元素追加到另一个切片中
	var c = []int{1, 2, 3}
	var d = []int{0, 9, 8}
	fmt.Println("追加前c:", len(c), cap(c), c)    // 追加前c: 3 3 [1 2 3]
	fmt.Println("要追加的内容d:", len(d), cap(d), d) // 要追加的内容d: 3 3 [0 9 8]
	// d...表示将切片d拆开得到其中的元素 并追加到c中
	c = append(c, d...)
	fmt.Println("追加后c:", len(c), cap(c), c)         // 追加后c: 6 6 [1 2 3 0 9 8]
	fmt.Println("对于拆开的切片d没有影响:", len(d), cap(d), d) // 对于拆开的切片d没有影响: 3 3 [0 9 8]
	// copy()
	e := []int{1, 2, 3, 4, 5}
	f := []int{9, 8, 7, 6}
	g := make([]int, 5, 10)
	copy(g, e)                              // 将e的数据赋值给g
	fmt.Printf("e=%v f=%v g=%v\n", e, f, g) // e=[1 2 3 4 5] f=[9 8 7 6] g=[1 2 3 4 5]
	// copy()仅复制数据 两个切片的指向不同
	e[1] = 999
	fmt.Printf("e=%v f=%v g=%v\n", e, f, g) // e=[1 999 3 4 5] f=[9 8 7 6] g=[1 2 3 4 5]
	// 从切片删除元素没有特定的函数与方法，是通过切片再切片与append的方法实现
	h := make([]int, 5, 10)
	h = []int{1, 2, 3, 4, 5}
	// 删除下标为2的元素
	h = append(h[:2], h[3:]...) // 切片再切片 跳过下标为2的元素
	fmt.Println(h)              // [1 2 4 5]
	// 当切片指向一个数组变量再去删除切片中的一个元素
	i := [5]int{1, 2, 3, 4, 5}
	j := i[:]                          // 指向数组i中的第一个元素
	fmt.Printf("删除前切片地址%p\n", j)       // 删除前切片地址0xc00000e510
	fmt.Printf("删除元素前数组首元素地址%p\n", &i) // 删除元素前数组首元素地址0xc00000e540
	// 使用切片j删除第二个元素
	j = append(j[:1], j[2:]...)
	fmt.Printf("删除后切片地址%p\n", j)       // 删除后切片地址0xc00000e510
	fmt.Printf("删除元素后数组首元素地址%p\n", &i) // 删除元素后数组首元素地址0xc00000e540
	fmt.Printf("i=%v j=%v\n", i, j)    // i=[1 3 4 5 5] j=[1 3 4 5]
	/*
		元素删除前后，数组与切片地址都没变，因此删除元素后的数组与删除前的数组是同一个，并且切片指向的底层数组也是这一个，
		切片删除元素实际是修改了底层数组，逐个元素往前挪，最后空位置由最后一个元素补充。
	*/
}
